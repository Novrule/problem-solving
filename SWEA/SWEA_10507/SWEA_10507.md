# SWEA_10507 - 영어 공부

## 문제

수림이는 영어 공부를 도와주는 스마트폰 앱을 사용하고 있다.

이 앱에는 영어 공부를 한 날에는 점수가 전날보다 1씩 쌓이고, 접속하지 않으면 점수가 0이 되는 “연속 공부 기간” 점수가 존재한다.

앱에는 랭킹 시스템이 있는데, 수림이가 그동안 적립했던 점수 중 최댓값을 가지고 다른 사람들과 경쟁한다.

즉, 영어 공부를 매일매일 했던 연속 기간이 길면 길수록 랭킹에서 유리하다.

수림이는 영어 공부보다는 해킹을 더 좋아해서, p개의 날짜에 대해서 영어 공부를 실제로 하지 않았더라도 한 날이라고 체크할 수 있는 방법을 알아냈다.

수림이가 p개의 날짜를 적절히 체크를 하였을 때, 영어 공부를 매일매일 했던 연속 기간의 최대 가능한 길이를 구하여라.

## 입력

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 영어 공부를 한 날의 수, 추가로 체크할 수 있는 날의 수를 의미하는 자연수 n, p가 주어진다. (1 ≤ n, p ≤ 200,000).

두 번째 줄에는 n개의 서로 다른 정수가 증가하는 순서대로 주어진다. 이들은 수림이가 영어 공부를 실제로 한 날의 번호들이다. 번호의 크기는 0 이상 $10^6$ 이하이다..

## 출력

각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,

연속 공부 기간의 가능한 최대 길이를 출력하라.

## 예제 입력

```
2
5 2
3 5 6 10 11
2 10
42 420
```

## 예제 출력

```
#1 5
#2 11
```

## 문제 풀이

2와 3을 가지고 7을 만들어야 한다고 가정해보자.

D를 X에 더해 X를 1로 만들고 D에 2와 3을 곱해서 6을 만든 후 이를 X에 더해 7을 만들 수 있다.  
따라서 X에 D를 더하는 횟수를 최소화 한 횟수는 2번이 된다.

그런데 이를 거꾸로 생각해보면 7에서 3을 나누면 몫이 2가 되고 나머지가 1이 되고,  
여기서 나온 몫인 2를 2로 나누면 몫이 1이 되고 나머지가 0이 된다.  
그리고 여기서 나온 몫인 1은 더이상 나누어지지 않으므로 나머지라고 생각할 수 있다.  
또한, 이 과정에서 나온 나머지의 합은 2가 되는데, 이는 앞에서 구한 X에 D를 더하는 최소 횟수와 같다.

이처럼 K를 A의 원소로 더이상 나눌 수 없을 때까지 나눴을 때 생기는 나머지의 합의 최소값을 구하면,  
이 값은 X에 D를 더하는 최소 횟수와 같으므로 X에 D를 더하는 최소 횟수를 구할 수 있게 된다.

이를 코드로 구현하기 위해서 먼저 `input` 함수에서 입력을 받아주었고,  
`solve` 함수에서 앞에서 설명한 과정을 통해 X에 D를 더하는 최소 횟수를 구할 수 있도록 해주었는데,  
이 때, K를 A의 원소로 나누는 과정을 저장하는 우선순위 큐인 `pq`를 도입해 최소 횟수를 구할 수 있도록 해주었다.  
그리고 `output` 함수를 통해서 조건에 맞게 `solve` 함수에서 구한 답을 출력해 줄 수 있도록 해주었다.

그런데 이 때, `pair<int, int>`를 `typedef`를 통해 `pii`로 선언해주었는데,  
이를 `using namespace std`보다 위에 선언해 오류가 발생했었고,  
`using namespace std`보다 아래에 선언해주는 방식으로 오류를 해결해주었다.
