# BOJ_2294 - 동전 2

|       시간 제한       | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------------------: | :---------: | :---: | :---: | :-------: | :-------: |
| 1 초 (추가 시간 없음) |   128 MB    | 69155 | 21054 |   14924   |  29.644%  |

## 문제

n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다.  
그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.

## 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000)  
다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.  
가치가 같은 동전이 여러 번 주어질 수도 있다.

## 출력

첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

## 예제 입력

```
3 15
1
5
12
```

## 예제 출력

```
3
```

## 문제 풀이

만약에 1원, 5원, 12원의 동전이 있고 그 것들로 15원을 만들어야 한다고 생각해보자.

그런데 만약 1원만 사용하게 된다면, 1원을 만드는 동전의 최소 개수는 1개이고, 2원을 만드는 동전의 최소 개수는 2개가 될 것이다.  
이와 마찬가지로, 15원을 만드는 동전의 최소 개수는 15개가 될 것이다.  
그러나 1원과 5원을 동시에 사용하게 된다면, 15원을 만드는 동전의 최소 개수는 5원짜리를 3개 사용한 3개로 갱신될 것이다.

이처럼 동전을 1개만 사용했을때의 최소값을 구해주고, 2개를 사용했을 때 최소값을 구해 갱신해주는 나가는 과정을 반복하면,  
우리가 원하는 가치의 합을 만드는 동전의 최소 개수를 구할 수 있게 된다.

이를 코드로 구현하기 위해서 먼저 `input` 함수에서 입력을 받아주었다.  
그리고 `dp` 함수에서 동전의 최소 개수를 저장하는 `dp` 배열을 도입하게 되었고,  
앞에서 말했던 것과 같이 `dp` 배열을 채워나가면서 원하는 가치의 합을 만드는 경우의 수를 구할 수 있도록 해주었다.

그런데 이 과정을 수행하기 위해서는 맨 처음에 `dp` 배열의 값을 초기화해야 하는데,  
초기화 하는 값을 `INT_MAX`로 진행하니 `dp` 배열을 채워가는 과정에서 `INT_MAX`에 1을 더해주는 경우가 생겨 오버플로우가 발생했다.  
그래서 `dp` 배열의 값을 초기화할 때 나올 수 있는 최대값인 10000보다 1이 더 큰 10001로 초기화해주는 방식으로 오류를 해결해주었다.
